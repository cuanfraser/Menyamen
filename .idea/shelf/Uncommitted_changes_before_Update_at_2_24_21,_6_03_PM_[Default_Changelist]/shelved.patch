Index: Snarl/Game/snarl/src/main/java/org/menyamen/snarl/App.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.menyamen.snarl;\n\nimport java.awt.Point;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.menyamen.snarl.layout.Hallway;\nimport org.menyamen.snarl.layout.Level;\nimport org.menyamen.snarl.layout.Room;\nimport org.menyamen.snarl.objects.ExitPortal;\nimport org.menyamen.snarl.objects.GameObject;\nimport org.menyamen.snarl.objects.Key;\n\n/**\n * Main Class\n */\npublic final class App {\n    private App() {\n    }\n\n    /**\n     * Program entry point\n     * @param args The arguments of the program.\n     */\n    public static void main(String[] args) {\n\n        // Example 1\n\n        Room room1 = new Room(new Point(0, 0));\n        Room room2 = new Room(new Point(15, 0), 10, 7);\n\n        List<Room> testRooms= new ArrayList<Room>();\n        testRooms.add(room1);\n        testRooms.add(room2);\n\n        Hallway hallway1 = new Hallway(new Point(10, 2), new Point(14, 2));\n\n        List<Hallway> testHallways = new ArrayList<Hallway>();\n        testHallways.add(hallway1);\n\n        Level testLevel = new Level(testRooms, testHallways, 40, 11);\n\n        GameObject key = new Key();\n        GameObject portal = new ExitPortal();\n\n        testLevel.addObject(key, new Point(4, 7));\n        testLevel.addObject(portal, new Point(19, 2));\n        \n\n        System.out.println(\"Example 1:\");\n        String printed = testLevel.print();\n\n        System.out.println(printed);\n\n        // Example 2\n\n        Room ex2Room1 = new Room(new Point(0, 0), 5, 5);\n        Room ex2Room2 = new Room(new Point(20, 10), 5, 7);\n\n        List<Room> ex2TestRooms= new ArrayList<Room>();\n        ex2TestRooms.add(ex2Room1);\n        ex2TestRooms.add(ex2Room2);\n\n        List<Point> waypoints = new ArrayList<Point>();\n        waypoints.add(new Point(5, 2));\n        waypoints.add(new Point(10, 2));\n        waypoints.add(new Point(10, 12));\n        waypoints.add(new Point(19, 12));\n\n        Hallway ex2Hallway1 = new Hallway(waypoints);\n\n        List<Hallway> ex2TestHallways = new ArrayList<Hallway>();\n        ex2TestHallways.add(ex2Hallway1);\n\n        Level ex2TestLevel = new Level(ex2TestRooms, ex2TestHallways, 40, 20);\n\n        GameObject ex2Key = new Key();\n        GameObject ex2Portal = new ExitPortal();\n\n        ex2TestLevel.addObject(ex2Key, new Point(2, 1));\n        ex2TestLevel.addObject(ex2Portal, new Point(22, 13));\n        \n\n        String ex2Printed = ex2TestLevel.print();\n\n        System.out.println(\"Example 2:\");\n        System.out.println(ex2Printed);\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Snarl/Game/snarl/src/main/java/org/menyamen/snarl/App.java	(revision 98b7a765c873c2a60922bb78203b8b0dd57b925a)
+++ Snarl/Game/snarl/src/main/java/org/menyamen/snarl/App.java	(date 1614142716752)
@@ -45,7 +45,7 @@
 
         testLevel.addObject(key, new Point(4, 7));
         testLevel.addObject(portal, new Point(19, 2));
-        
+
 
         System.out.println("Example 1:");
         String printed = testLevel.print();
@@ -79,11 +79,77 @@
 
         ex2TestLevel.addObject(ex2Key, new Point(2, 1));
         ex2TestLevel.addObject(ex2Portal, new Point(22, 13));
-        
+
 
         String ex2Printed = ex2TestLevel.print();
 
         System.out.println("Example 2:");
         System.out.println(ex2Printed);
+
+        // Example 3
+
+        Room ex3Room1 = new Room(new Point(0, 0), 10, 3);
+        Room ex3Room2 = new Room(new Point(15, 15), 5, 5);
+
+        List<Room> ex3TestRooms= new ArrayList<Room>();
+        ex3TestRooms.add(ex3Room1);
+        ex3TestRooms.add(ex3Room2);
+
+        List<Point> waypoints2 = new ArrayList<Point>();
+        waypoints2.add(new Point(5, 3));
+        waypoints2.add(new Point(5, 17));
+        waypoints2.add(new Point(14, 17));
+
+        Hallway ex3Hallway1 = new Hallway(waypoints2);
+
+        List<Hallway> ex3TestHallways = new ArrayList<Hallway>();
+        ex3TestHallways.add(ex3Hallway1);
+
+        Level ex3TestLevel = new Level(ex3TestRooms, ex3TestHallways, 40, 30);
+
+        GameObject ex3Key = new Key();
+        GameObject ex3Portal = new ExitPortal();
+
+        ex3TestLevel.addObject(ex3Key, new Point(1, 1));
+        ex3TestLevel.addObject(ex3Portal, new Point(16, 16));
+
+
+        String ex3Printed = ex3TestLevel.print();
+
+        System.out.println("Example 3:");
+        System.out.println(ex3Printed);
+
+        // Example 4
+
+        Room ex4Room1 = new Room(new Point(0, 0), 5, 20);
+        Room ex4Room2 = new Room(new Point(10, 0), 5, 5);
+
+        List<Room> ex4TestRooms= new ArrayList<Room>();
+        ex4TestRooms.add(ex4Room1);
+        ex4TestRooms.add(ex4Room2);
+
+        List<Point> waypoints3 = new ArrayList<Point>();
+        waypoints3.add(new Point(4, 16));
+        waypoints3.add(new Point(11, 16));
+        waypoints3.add(new Point(11, 4));
+
+        Hallway ex4Hallway1 = new Hallway(waypoints3);
+
+        List<Hallway> ex4TestHallways = new ArrayList<Hallway>();
+        ex4TestHallways.add(ex4Hallway1);
+
+        Level ex4TestLevel = new Level(ex4TestRooms, ex4TestHallways, 30, 30);
+
+        GameObject ex4Key = new Key();
+        GameObject ex4Portal = new ExitPortal();
+
+        ex4TestLevel.addObject(ex4Key, new Point(11, 1));
+        ex4TestLevel.addObject(ex4Portal, new Point(1, 1));
+
+
+        String ex4Printed = ex4TestLevel.print();
+
+        System.out.println("Example 4:");
+        System.out.println(ex4Printed);
     }
 }
Index: Snarl/Planning/state.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># SNARL GAME STATES  \n#### FULL STATE - GAME MANAGER   \nHere are the methods and data that will be available to the full state Game Manager. The full state will be able to access a list of players, a list of rooms, a list of hallways, a list of adversaries, the game object locations (key and exit), all the levels, the cartesian location of every room, and the location of every player or adversary. The game manager will act as a sort of server for our game and hold all the data necessary to initiate the game, validate a list of players, place the game objects, place the adversaries, place the players, generate the tiles to create the board of rooms and hallways.  \n##### METHODS:  \n```java\n     // Generates map for Level from List of Rooms and List of Hallways if valid, palces players, adversaries, and game objects (key and exit)\n     void generateLevel() \n    \n     /**\n      * Checks if Room has a valid placement in the current Level.\n      * @param room Room to test validity.\n      * @return True if valid, false if invalid.\n      */\n     public boolean validRoomPlacement(Room room)\n    \n     /**\n      * Add a player to the game\n      * @param Player to add\n      * @return List of players\n      */\n     private List<Player> addPlayer(Player player)\n\n     /**\n      * Removes a player from the game\n      * @param Player to remove \n      * @return List of players\n      */\n     private List<Player> removePlayer(Player player)\n\n    /**\n     * Checks if Hallway has a valid placement in current Level.\n     * @param hallway Hallway to test.\n     * @return True if valid, false if invalid.\n     */\n    public Boolean validHallwayPlacement(Hallway hallway)\n\n     // Ends the game if either the player or adversary wins\n     private void endGame() \n```\n##### DATA:  \n```java\n    - List of rooms (World generation)\n    - List of hallways\n    - Location of rooms \n    - Location of key \n    - Location of exit \n    - Current level \n    - Total number of levels\n    - List of players in order \n    - List of adversaries\n    - Number of players alive\n    - Number of adversaries in a room \n    - Number of players in a room \n    - Specific location of board (cartesian point) \n    - Specific position of player in a room\n    - Specific position of adversary in a room\n```\n#### LIMITED STATE - PLAYER \nUnlike the Full State in the Game Manager the Limited Player State has less data access and less control over the game. The player can only view the tiles immediately in its vicinity meaning the tiles immediately upward, downward, to the left, or the right of the tile the player is currently on. The player will also know which level it is on but not have access to all levels. The player will know it's own location and how many other players are still in the game. \n##### METHODS: \n```java\n    /**\n     * If a player runs into an adversary the player gets removed from the game, sends to the full state which removes the player from the game\n     * @param Player to get expelled\n     */\n    public void getExpelled(Player player)\n\n    /**\n     * Removes the key if found by a player\n     * @param The Player who just moved and the Key that was found\n     */\n    public void findKey(Player player, Key key)\n\n    /**\n     * Exits level if player reaches portal with the key\n     * @param Player that is exiting\n     */\n    public void findExit(Player player)\n\n    /**\n     * Allows a player to move up, down, right, or left.\n     * @param Player player\n     */\n    public void Move(Player player)\n\n    /**\n     * If a player reaches the last exit portal in the last level then they have exited the dungeon and won\n     * @param Player to win\n     */\n    public void Win(Player player)\n\n    /**\n     * If a player is the last to get expelled then the adversaries have won (all players get expelled in the current level)\n     * @param Player to lose\n     */\n    public void Lose(Player player)\n```\n##### DATA:  \n```java\n    - Tiles directly in vicinity of player (x + 1, x - 1, y + 1, y - 1)\n    - Current level the player is in\n    - Number of players alive\n    - Specific position of player in a room\n```\n#### LIMITED STATE - ADVERSARY \nIn addition to the Limited Player State the Adversary state also is limited in comparison to the full game manager state. The adversary has fewer data access points and less control over the game. The adversary can see the number of rooms, hallways, and players alive in the current level. Adversaries can see the specific position of a player in a room, the specific position of an adversary in a room, the location of the key and exit portal. They can expel a player if they move onto the same tile as the player or vice versa. They can also move up, down, right, or left by one tile (no diagonal moves). They can win if they expel all players in the current level. They can lose if a player reaches the last exit portal in the last level of the game.                                                                                                                                                                                                                                                                                           \n##### METHODS: \n```java\n    /**\n     * If a player runs into an adversary the player gets removed from the current level, but is added to the next level if it exists. \n     * @param Player to get expelled\n     */\n    public void expelPlayer(Player player)\n\n    /**\n     * Allows an adversary to move up, down, right, or left.\n     * @param Adversary adversary\n     */\n    public void Move(Adversary adversary)\n\n    /**\n     * If all players are expelled in the current level then the Adversaries win.\n     * @param Adversary adversary to win\n     */\n    public void Win(Adversary adversary)\n\n    /**\n     * If a player gets to the last exit portal in the last level then the Adversary loses\n     * @param Adversary to lose\n     */\n    public void Lose(Adversary adversary)\n```\n##### DATA:  \n```java\n    - Number of rooms \n    - Number of hallways \n    - Current level\n    - Number of players alive\n    - Number of adversaries in a room \n    - Number of players in a room \n    - Specific position of player in a room\n    - Specific position of adversary in a room\n    - Location of key \n    - Location of exit portal\n```
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Snarl/Planning/state.md	(revision 98b7a765c873c2a60922bb78203b8b0dd57b925a)
+++ Snarl/Planning/state.md	(date 1614124601638)
@@ -3,7 +3,7 @@
 Here are the methods and data that will be available to the full state Game Manager. The full state will be able to access a list of players, a list of rooms, a list of hallways, a list of adversaries, the game object locations (key and exit), all the levels, the cartesian location of every room, and the location of every player or adversary. The game manager will act as a sort of server for our game and hold all the data necessary to initiate the game, validate a list of players, place the game objects, place the adversaries, place the players, generate the tiles to create the board of rooms and hallways.  
 ##### METHODS:  
 ```java
-     // Generates map for Level from List of Rooms and List of Hallways if valid, palces players, adversaries, and game objects (key and exit)
+     // Generates map for Level from List of Rooms and List of Hallways if valid, places players, adversaries, and game objects (key and exit)
      void generateLevel() 
     
      /**
Index: Snarl/Game/snarl/src/main/java/org/menyamen/snarl/layout/Hallway.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.menyamen.snarl.layout;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.menyamen.snarl.tiles.Door;\nimport org.menyamen.snarl.tiles.OpenTile;\nimport org.menyamen.snarl.tiles.Tile;\nimport org.menyamen.snarl.tiles.Wall;\n\nimport java.awt.Point;\n\npublic class Hallway {\n    private List<Point> waypoints;\n    private List<Tile> tiles;\n    private List<Tile> doors;\n\n    /**\n     * Create Hallway from given start Point to given end Point.\n     * @param start Point to start Hallway.\n     * @param end Point to end Hallway.\n     */\n    public Hallway(Point start, Point end) {\n        this.waypoints = new ArrayList<Point>();\n        this.waypoints.add(start);\n        this.waypoints.add(end);\n        this.generateTiles();\n    }\n\n    /**\n     * Create Hallway from given Waypoints.\n     * @param waypoints List of Waypoints to create Hallway from.\n     */\n    public Hallway(List<Point> waypoints) {\n        this.waypoints = waypoints;\n        this.generateTiles();\n    }\n\n    /**\n     * Generates the tiles needed for the Hallway.\n     * @return Tiles generated.\n     * @throws IllegalArgumentException if a waypoint is not vertical/horizontal.\n     */\n    protected List<Tile> generateTiles() throws IllegalArgumentException{\n\n        tiles = new ArrayList<Tile>();\n        doors = new ArrayList<Tile>();\n\n        // Up (U), Down (D), Left (L), Right (R)\n        char prevDir = ' ';\n\n        // Loop Waypoints\n        for (int i = 0; i + 1 < waypoints.size(); i++) {\n\n            int x1 = waypoints.get(i).x;\n            int y1 = waypoints.get(i).y;\n            int x2 = waypoints.get(i + 1).x;\n            int y2 = waypoints.get(i + 1).y;\n\n            if (x1 == x2 && y1 == y2) {\n                throw new IllegalArgumentException(\"Hallways can only be Horizontal or Vertical\");\n            }\n\n            // Equal y cord, horiz hallway\n            if (y1 == y2) {\n                // Going right\n                if (x2 - x1 >= 0) {\n                    // Add first door\n                    if (i == 0) {\n                        Tile door = new Door(x1 - 1, y1);\n                        doors.add(door);\n                    }\n                    // Add last door\n                    if (i + 1 == waypoints.size() - 1) {\n                        Tile door = new Door(x2 + 1, y2);\n                        doors.add(door);\n                    }\n                    //Loop path\n                    for (int j = x1; j <= x2; j++) {\n                        // Start of Waypoint Special Case for Turns\n                        if (j == x1 && i != 0) {\n                            if (prevDir == 'D') {\n                                // Add Bottom Left Wall\n                                tiles.add(new Wall(j - 1, y1 + 1));\n                                tiles.add(new OpenTile(j, y1));\n                                tiles.add(new Wall(j, y1 + 1));\n                            }\n                        }\n                        // TODO: Further Special Cases\n                        else {\n                            tiles.add(new Wall(j, y1 - 1));\n                            tiles.add(new OpenTile(j, y1));\n                            tiles.add(new Wall(j, y1 + 1));\n                        }\n\n                    }\n                    prevDir = 'R';\n                }\n                // Going left\n                else {\n                    // Add first door\n                    if (i == 0) {\n                        Tile door = new Door(x1 + 1, y1);\n                        doors.add(door);\n                    }\n                    // Add last door\n                    if (i + 1 == waypoints.size() - 1) {\n                        Tile door = new Door(x2 - 1, y2);\n                        doors.add(door);\n                    }\n                    for (int j = x2; j <= x1; j++) {\n                        // TODO: Further Special Cases\n                        tiles.add(new Wall(j, y1 - 1));\n                        tiles.add(new OpenTile(j, y1));\n                        tiles.add(new Wall(j, y1 + 1));\n                    }\n                    prevDir = 'L';\n                }\n            }\n            // Equal x cord, vertical hallway\n            else if (x1 == x2) {\n                // Going down\n                if (y2 - y1 >= 0) {\n                    // Add first door\n                    if (i == 0) {\n                        Tile door = new Door(x1, y1 - 1);\n                        doors.add(door);\n                    }\n                    // Add last door\n                    if (i + 1 == waypoints.size() - 1) {\n                        Tile door = new Door(x2, y2 + 1);\n                        doors.add(door);\n                    }\n                    for (int j = y1; j <= y2; j++) {\n                        // Start of Waypoint Special Case for Turns\n                        if (j == y1 && i != 0) {\n                            if (prevDir == 'R') {\n                                // Add Top Right Wall\n                                tiles.add(new Wall(x1 + 1, j - 1));\n                                tiles.add(new OpenTile(x1, j));\n                                tiles.add(new Wall(x1 + 1, j));\n                            }\n                            // TODO: Further Special Cases\n                        }\n                        else {\n                            tiles.add(new Wall(x1 - 1, j));\n                            tiles.add(new OpenTile(x1, j));\n                            tiles.add(new Wall(x1 + 1, j));\n                        }\n                    }\n                    prevDir = 'D';\n                        \n                }\n                // Going up\n                else {\n                    // Add first door\n                    if (i == 0) {\n                        Tile door = new Door(x1, y1 + 1);\n                        doors.add(door);\n                    }\n                    // Add last door\n                    if (i + 1 == waypoints.size() - 1) {\n                        Tile door = new Door(x2, y2 - 1);\n                        doors.add(door);\n                    }\n                    for (int j = y2; j <= y1; j++) {\n                        // TODO: Further Special Cases\n                        tiles.add(new Wall(x1 - 1, j));\n                        tiles.add(new OpenTile(x1, j));\n                        tiles.add(new Wall(x1 + 1, j));\n                    }\n                    prevDir = 'U';\n                }\n            }\n        }\n\n        return tiles;\n\n    }\n\n    protected List<Point> getWaypoints() {\n        return this.waypoints;\n    }\n\n    protected List<Tile> getTiles() {\n        return this.tiles;\n    }\n\n    protected List<Tile> getDoors() {\n        return this.doors;\n    }\n    \n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Snarl/Game/snarl/src/main/java/org/menyamen/snarl/layout/Hallway.java	(revision 98b7a765c873c2a60922bb78203b8b0dd57b925a)
+++ Snarl/Game/snarl/src/main/java/org/menyamen/snarl/layout/Hallway.java	(date 1614142822984)
@@ -41,7 +41,7 @@
      * @return Tiles generated.
      * @throws IllegalArgumentException if a waypoint is not vertical/horizontal.
      */
-    protected List<Tile> generateTiles() throws IllegalArgumentException{
+    protected List<Tile> generateTiles() throws IllegalArgumentException {
 
         tiles = new ArrayList<Tile>();
         doors = new ArrayList<Tile>();
@@ -85,8 +85,21 @@
                                 tiles.add(new OpenTile(j, y1));
                                 tiles.add(new Wall(j, y1 + 1));
                             }
+                            if (prevDir == 'U') {
+                                // Add Top Left Wall
+                                tiles.add(new Wall(j, y1 + 1));
+                                tiles.add(new OpenTile(j, y1));
+                                tiles.add(new Wall(j + 1, y1));
+                            }
+
+                            if (prevDir == 'L') {
+
+                                throw new IllegalArgumentException("Can not go right to left");
+                            }
+
                         }
-                        // TODO: Further Special Cases
+
+                        // Going further right
                         else {
                             tiles.add(new Wall(j, y1 - 1));
                             tiles.add(new OpenTile(j, y1));
@@ -96,6 +109,7 @@
                     }
                     prevDir = 'R';
                 }
+
                 // Going left
                 else {
                     // Add first door
@@ -109,14 +123,35 @@
                         doors.add(door);
                     }
                     for (int j = x2; j <= x1; j++) {
-                        // TODO: Further Special Cases
-                        tiles.add(new Wall(j, y1 - 1));
-                        tiles.add(new OpenTile(j, y1));
-                        tiles.add(new Wall(j, y1 + 1));
+                        // Start of Waypoint Special Case for Turns
+                        if (j == x2 && i != 0) {
+                            if (prevDir == 'D') {
+                                // Add Top Left Wall
+                                tiles.add(new Wall(j, y1 + 1));
+                                tiles.add(new OpenTile(j, y1));
+                                tiles.add(new Wall(j + 1, y1));
+                            }
+                            if (prevDir == 'U') {
+                                // Add Bottom Left Wall
+                                tiles.add(new Wall(j - 1, y1 + 1));
+                                tiles.add(new OpenTile(j, y1));
+                                tiles.add(new Wall(j, y1 + 1));
+                            }
+                            if (prevDir == 'R') {
+                                throw new IllegalArgumentException("Can not go left to right");
+                            }
+                        }
+                        // Going further left
+                        else {
+                            tiles.add(new Wall(j, y1 - 1));
+                            tiles.add(new OpenTile(j, y1));
+                            tiles.add(new Wall(j, y1 + 1));
+                        }
                     }
                     prevDir = 'L';
                 }
             }
+
             // Equal x cord, vertical hallway
             else if (x1 == x2) {
                 // Going down
@@ -138,10 +173,19 @@
                                 // Add Top Right Wall
                                 tiles.add(new Wall(x1 + 1, j - 1));
                                 tiles.add(new OpenTile(x1, j));
-                                tiles.add(new Wall(x1 + 1, j));
+                                tiles.add(new Wall(x1, j + 1));
+                            }
+                            if (prevDir == 'L') {
+                                // Add Bottom Right Wall
+                                tiles.add(new Wall(x1 - 1, j + 1));
+                                tiles.add(new OpenTile(x1, j));
+                                tiles.add(new Wall(x1 - 1, j));
                             }
-                            // TODO: Further Special Cases
+                            if (prevDir == 'U') {
+                                throw new IllegalArgumentException("Can not go down to up");
+                            }
                         }
+                        //keep going down
                         else {
                             tiles.add(new Wall(x1 - 1, j));
                             tiles.add(new OpenTile(x1, j));
@@ -149,8 +193,8 @@
                         }
                     }
                     prevDir = 'D';
-                        
                 }
+
                 // Going up
                 else {
                     // Add first door
@@ -163,18 +207,35 @@
                         Tile door = new Door(x2, y2 - 1);
                         doors.add(door);
                     }
+                    // Start of Waypoint Special Case for Turns
                     for (int j = y2; j <= y1; j++) {
-                        // TODO: Further Special Cases
-                        tiles.add(new Wall(x1 - 1, j));
-                        tiles.add(new OpenTile(x1, j));
-                        tiles.add(new Wall(x1 + 1, j));
-                    }
-                    prevDir = 'U';
+                        if (j == y2 && i != 0) {
+                            if (prevDir == 'R') {
+                                tiles.add(new Wall(x1 - 1, j + 1));
+                                tiles.add(new OpenTile(x1, j));
+                                tiles.add(new Wall(x1 + 1, j + 1));
+                            }
+                            if (prevDir == 'L') {
+                                tiles.add(new Wall(x1 + 1, j - 1));
+                                tiles.add(new OpenTile(x1, j));
+                                tiles.add(new Wall(x1 - 1, j - 1));
+                            }
+                            if (prevDir == 'D') {
+                                throw new IllegalArgumentException("Can not go up to down");
+                            }
+                        }
+                        //keep going up
+                        else {
+                            tiles.add(new Wall(x1 - 1, j));
+                            tiles.add(new OpenTile(x1, j));
+                            tiles.add(new Wall(x1 + 1, j));
+                        }
+                        prevDir = 'U';
+                    }
                 }
             }
         }
-
-        return tiles;
+            return tiles;
 
     }
 
@@ -189,5 +250,5 @@
     protected List<Tile> getDoors() {
         return this.doors;
     }
-    
-}
\ No newline at end of file
+
+}
Index: Snarl/Game/snarl/src/main/java/org/menyamen/snarl/tiles/OpenTile.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.menyamen.snarl.tiles;\n\nimport java.awt.Point;\n\nimport org.menyamen.snarl.objects.GameObject;\n\npublic class OpenTile implements Tile {\n    private Boolean isOccupied;\n    private GameObject gameObject;\n    private Point pos;\n\n    public OpenTile(int x, int y) {\n        this.pos = new Point(x, y);\n        this.isOccupied = false;\n    }\n\n    public OpenTile(int x, int y, Boolean isOccupied, GameObject gameObject, Boolean isDoor) {\n        this.pos = new Point(x, y);\n        this.isOccupied = isOccupied;\n        this.gameObject = gameObject;\n    }\n    \n    @Override\n    public GameObject getGameObject() {\n        return gameObject;\n    }\n\n    @Override\n    public Boolean setGameObject(GameObject gameObject) {\n        this.gameObject = gameObject;\n        return true;\n    }\n\n    public Boolean getIsOccupied() {\n        return isOccupied;\n    }\n\n    public void setIsOccupied(Boolean isOccupied) {\n        this.isOccupied = isOccupied;\n    }\n\n    @Override\n    public char toChar() {\n        return '.';\n    }\n\n    @Override\n    public Point getPos() {\n        return pos;\n    }\n\n    // Credit: https://www.geeksforgeeks.org/overriding-equals-method-in-java/\n    @Override\n    public boolean equals(Object o) { \n        // If the object is compared with itself then return true   \n        if (o == this) { \n            return true; \n        } \n    \n        /* Check if o is an instance of OpenTile or not \n            \"null instanceof [type]\" also returns false */\n        if (!(o instanceof OpenTile)) { \n            return false; \n        } \n            \n        // typecast o to OpenTile so that we can compare data members  \n        OpenTile c = (OpenTile) o; \n            \n        // Compare the data members and return accordingly  \n        return pos == c.pos ;\n    } \n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Snarl/Game/snarl/src/main/java/org/menyamen/snarl/tiles/OpenTile.java	(revision 98b7a765c873c2a60922bb78203b8b0dd57b925a)
+++ Snarl/Game/snarl/src/main/java/org/menyamen/snarl/tiles/OpenTile.java	(date 1614123656004)
@@ -9,6 +9,7 @@
     private GameObject gameObject;
     private Point pos;
 
+
     public OpenTile(int x, int y) {
         this.pos = new Point(x, y);
         this.isOccupied = false;
@@ -19,7 +20,7 @@
         this.isOccupied = isOccupied;
         this.gameObject = gameObject;
     }
-    
+
     @Override
     public GameObject getGameObject() {
         return gameObject;
@@ -51,22 +52,22 @@
 
     // Credit: https://www.geeksforgeeks.org/overriding-equals-method-in-java/
     @Override
-    public boolean equals(Object o) { 
-        // If the object is compared with itself then return true   
-        if (o == this) { 
-            return true; 
-        } 
-    
-        /* Check if o is an instance of OpenTile or not 
+    public boolean equals(Object o) {
+        // If the object is compared with itself then return true
+        if (o == this) {
+            return true;
+        }
+
+        /* Check if o is an instance of OpenTile or not
             "null instanceof [type]" also returns false */
-        if (!(o instanceof OpenTile)) { 
-            return false; 
-        } 
-            
-        // typecast o to OpenTile so that we can compare data members  
-        OpenTile c = (OpenTile) o; 
-            
-        // Compare the data members and return accordingly  
+        if (!(o instanceof OpenTile)) {
+            return false;
+        }
+
+        // typecast o to OpenTile so that we can compare data members
+        OpenTile c = (OpenTile) o;
+
+        // Compare the data members and return accordingly
         return pos == c.pos ;
-    } 
-}
\ No newline at end of file
+    }
+}
Index: Snarl/Game/snarl/src/main/java/org/menyamen/snarl/layout/Level.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.menyamen.snarl.layout;\n\nimport java.util.HashMap;\nimport java.util.List;\n\nimport org.menyamen.snarl.objects.GameObject;\nimport org.menyamen.snarl.tiles.OpenTile;\nimport org.menyamen.snarl.tiles.Tile;\nimport org.menyamen.snarl.tiles.Wall;\n\nimport java.awt.Point;\n\npublic class Level {\n    private List<Room> rooms;\n    private List<Hallway> hallways;\n    private HashMap<Point, Tile> map;\n    private int sizeX;\n    private int sizeY;\n\n    /**\n     * Construct Level from Rooms, Hallways and Size of Level.\n     * @param rooms Rooms to add to Level.\n     * @param hallways Hallways to add to Level.\n     * @param x Horizontal size of Level.\n     * @param y Vertical size of Level.\n     */\n    public Level(List<Room> rooms, List<Hallway> hallways, int x, int y) {\n        this.rooms = rooms;\n        this.hallways = hallways;\n        this.sizeX = x;\n        this.sizeY = y;\n        this.map = new HashMap<Point,Tile>();\n        this.generate();\n    }\n\n    /**\n     * Generates map for Level from List of Rooms and List of Hallways.\n     */\n    public void generate() {\n        for (Room singleRoom : rooms) {\n            if (validRoomPlacement(singleRoom)) {\n                singleRoom.addToMap(map, sizeX, sizeY);\n            }\n            \n        }\n        for (Hallway singleHallway: hallways) {\n            if (validHallwayPlacement(singleHallway)) {\n                List<Tile> tiles = singleHallway.getTiles();\n                for (Tile singleTile : tiles) {\n                    map.put(singleTile.getPos(), singleTile);\n                }\n                for (Tile singleDoor : singleHallway.getDoors()) {\n                    map.put(singleDoor.getPos(), singleDoor);\n                }\n            }\n        }\n    }\n\n    /**\n     * Checks if Room has a valid placement in current Level.\n     * @param room Room to test.\n     * @return True if valid, false if invalid.\n     */\n    public Boolean validRoomPlacement(Room room) {\n        int horizontalSize = room.getHorizontalSize();\n        int verticalSize = room.getVerticalSize();\n        Point origin = room.getOrigin();\n\n        for (int i = origin.y; i < origin.y + verticalSize; i++) {\n            for (int j = origin.x; j < origin.x + horizontalSize; j++) {\n                Point currentPos = new Point(j, i);\n                if (map.containsKey(currentPos)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Checks if Hallway has a valid placement in current Level.\n     * @param hallway Hallway to test.\n     * @return True if valid, false if invalid.\n     */\n    public Boolean validHallwayPlacement(Hallway hallway) {\n        List<Tile> tilesNeeded = hallway.getTiles();\n        List<Point> waypoints = hallway.getWaypoints();\n\n        if (!nextTo(waypoints.get(0), new Wall())) {\n            return false;\n        }\n\n        if (!nextTo(waypoints.get(waypoints.size() - 1), new Wall())) {\n            return false;\n        }\n\n\n        for (Tile currentTile : tilesNeeded) {\n            if (map.containsKey(currentTile.getPos())) {\n                return false;\n            }\n            if (currentTile.getPos().x > sizeX || currentTile.getPos().y > sizeY) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Is given Point in map next to a Tile of the same Class as given tile (above, below, left \n     * or right of given Point).\n     * @param point Point to check around on map.\n     * @param tile Tile of Class type to check for (e.g. Wall, OpenTile, Door).\n     * @return True if specified type is found, False if not.\n     */\n    private Boolean nextTo(Point point, Tile tile) {\n        Point above = new Point(point);\n        above.translate(0, -1);\n        Point below = new Point(point);\n        below.translate(0, 1);\n        Point left = new Point(point);\n        left.translate(-1, 0);\n        Point right = new Point(point);\n        right.translate(1, 0);\n\n        if (map.containsKey(above)) {\n            Tile ta = map.get(above);\n            if (ta.getClass() == tile.getClass()) {\n                return true;\n            }\n        }\n        if (map.containsKey(below)) {\n            Tile tb = map.get(below);\n            if (tb.getClass() == tile.getClass()) {\n                return true;\n            }\n        }\n        if (map.containsKey(left)) {\n            Tile tl = map.get(left);\n            if (tl.getClass() == tile.getClass()) {\n                return true;\n            }\n        }\n        if (map.containsKey(right)) {\n            Tile tr = map.get(right);\n            if (tr.getClass() == tile.getClass()) {\n                return true;\n            }\n        }\n        return false;\n\n    }\n\n    public Boolean addObject(GameObject object, Point position) {\n        if (map.containsKey(position)) {\n            if (map.get(position) instanceof OpenTile) {\n                return map.get(position).setGameObject(object);\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Print Level as ASCII String.\n     * @return Level as ASCII String.\n     */\n    public String print() {\n        StringBuilder builder = new StringBuilder();\n        for(int i = 0; i < sizeY; i++) {\n            for (int j = 0; j < sizeX; j++) {\n                Point pos = new Point(j, i);\n                if (map.containsKey(pos)) {\n                    Tile curTile = map.get(pos);\n                    if (curTile.getGameObject() != null) {\n                        builder.append(curTile.getGameObject().toChar());\n                    }\n                    else {\n                        builder.append(curTile.toChar());\n                    }\n                }\n                else {\n                    builder.append(' ');\n                }\n\n                if (j == (sizeX - 1)) {\n                    builder.append('\\n');\n                }\n            }\n        }\n        return builder.toString();\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Snarl/Game/snarl/src/main/java/org/menyamen/snarl/layout/Level.java	(revision 98b7a765c873c2a60922bb78203b8b0dd57b925a)
+++ Snarl/Game/snarl/src/main/java/org/menyamen/snarl/layout/Level.java	(date 1614138854854)
@@ -41,7 +41,7 @@
             if (validRoomPlacement(singleRoom)) {
                 singleRoom.addToMap(map, sizeX, sizeY);
             }
-            
+
         }
         for (Hallway singleHallway: hallways) {
             if (validHallwayPlacement(singleHallway)) {
@@ -87,7 +87,9 @@
         List<Point> waypoints = hallway.getWaypoints();
 
         if (!nextTo(waypoints.get(0), new Wall())) {
+            System.out.println("not working");
             return false;
+
         }
 
         if (!nextTo(waypoints.get(waypoints.size() - 1), new Wall())) {
@@ -107,7 +109,7 @@
     }
 
     /**
-     * Is given Point in map next to a Tile of the same Class as given tile (above, below, left 
+     * Is given Point in map next to a Tile of the same Class as given tile (above, below, left
      * or right of given Point).
      * @param point Point to check around on map.
      * @param tile Tile of Class type to check for (e.g. Wall, OpenTile, Door).
@@ -189,4 +191,4 @@
         }
         return builder.toString();
     }
-}
\ No newline at end of file
+}
